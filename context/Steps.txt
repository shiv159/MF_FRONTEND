Steps
Initialize project with complete Tailwind configuration — Run ng new mutual-fund-frontend --standalone --routing --style=css --skip-tests; configure angular.json to serve on port 3000; install npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p, npm install chart.js@^4.4.0; configure tailwind.config.js with darkMode: 'class', content: ['./src/**/*.{html,ts}'], safelist: ['text-green-500', 'text-red-500', 'text-yellow-500', 'bg-green-500', 'bg-red-500', 'bg-blue-500', 'border-green-500', 'border-red-500'] for dynamic validation states, extend theme with custom colors matching backend data (primary: '#2563eb', success: '#22c55e', danger: '#ef4444', warning: '#f59e0b'); add to src/styles.css Tailwind directives plus custom utilities: @layer utilities { .table-desktop { @apply hidden md:table; } .card-mobile { @apply md:hidden; } }.

Create modular Chart.js registration utility — Build src/app/shared/utils/chart-registry.ts with tree-shaken imports: import { Chart, LineController, LineElement, PointElement, LinearScale, CategoryScale, Filler, Tooltip, Legend, DoughnutController, ArcElement, Title } from 'chart.js'; export function registerCharts() { Chart.register(LineController, LineElement, PointElement, LinearScale, CategoryScale, Filler, Tooltip, Legend, DoughnutController, ArcElement, Title); }; call in app.config.ts providers array; create shared/utils/chart-theme-config.ts with export function getChartColors(isDark: boolean) { return { text: isDark ? '#e2e8f0' : '#1e293b', grid: isDark ? '#475569' : '#cbd5e1', background: isDark ? '#1e293b' : '#ffffff', optimistic: '#22c55e', expected: '#3b82f6', pessimistic: '#ef4444' }; } and export function updateChartTheme(chart: Chart, isDark: boolean) { const colors = getChartColors(isDark); chart.options.plugins!.legend!.labels!.color = colors.text; chart.options.plugins!.tooltip!.backgroundColor = colors.background; chart.options.scales!['x']!.grid!.color = colors.grid; chart.options.scales!['y']!.grid!.color = colors.grid; chart.update('none'); }.

Implement signal-based global state architecture — Create core/state/auth.state.ts: export class AuthState { authUser = signal<AuthResponse | null>(null); isAuthenticated = computed(() => !!this.authUser()); initialize() { const token = localStorage.getItem('access_token'); if (token) /* decode and set user */; } logout() { this.authUser.set(null); localStorage.removeItem('access_token'); } } with providedIn: 'root'; create core/state/theme.state.ts: export class ThemeState { isDarkMode = signal(false); constructor() { effect(() => { const dark = this.isDarkMode(); if (dark) document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark'); localStorage.setItem('theme', dark ? 'dark' : 'light'); }); this.initialize(); } initialize() { const saved = localStorage.getItem('theme'); this.isDarkMode.set(saved === 'dark' || (!saved && window.matchMedia('(prefers-color-scheme: dark)').matches)); } toggle() { this.isDarkMode.update(v => !v); } } as injectable singleton; create core/state/loading.state.ts, core/state/toast.state.ts, core/state/dashboard.state.ts with computed signals for derived data.

Build wealth projection chart with theme-aware updates — Create shared/components/wealth-cone-chart/wealth-cone-chart.component.ts with projection = input.required<WealthProjectionDTO>(), @ViewChild('canvas', {static: true}) canvasRef!: ElementRef<HTMLCanvasElement>, private chart?: Chart, ngAfterViewInit() creating chart: const colors = getChartColors(this.themeState.isDarkMode()); this.chart = new Chart(this.canvasRef.nativeElement, { type: 'line', data: { labels: this.projection().timeline.map(t => 'Year ${t.year}'), datasets: [{ label: 'Optimistic', data: this.projection().timeline.map(t => t.optimisticAmount), borderColor: colors.optimistic, backgroundColor: 'rgba(34, 197, 94, 0.1)', fill: true }, { label: 'Expected', data: this.projection().timeline.map(t => t.expectedAmount), borderColor: colors.expected, backgroundColor: 'rgba(59, 130, 246, 0.1)', fill: true }, { label: 'Pessimistic', data: this.projection().timeline.map(t => t.pessimisticAmount), borderColor: colors.pessimistic, backgroundColor: 'rgba(239, 68, 68, 0.1)', fill: true }] }, options: { ... } }); add effect for theme updates: effect(() => { const isDark = this.themeState.isDarkMode(); if (this.chart) updateChartTheme(this.chart, isDark); }), ngOnDestroy() { this.chart?.destroy(); }.

Create responsive holdings table with CSS breakpoints — Build features/dashboard/components/holdings-table/holdings-table.component.ts with holdings = input.required<HoldingDTO[]>(), sortField = signal<keyof HoldingDTO>('currentValue'), sortDirection = signal<'asc' | 'desc'>('desc'), currentPage = signal(1), pageSize = signal(10), expandedRows = signal<Set<string>>(new Set()), computed sortedHoldings, paginatedHoldings, totalPages; template with desktop table: <table class="table-desktop w-full border-collapse"><thead class="bg-gray-50 dark:bg-slate-800"><tr><th class="px-4 py-3 text-left text-xs font-semibold text-gray-700 dark:text-gray-300 uppercase tracking-wider cursor-pointer hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" (click)="sort('fundName')">Fund Name</th>...mobile cards: <div class="card-mobile space-y-4">@for (holding of paginatedHoldings(); track holding.holdingId) { <div class="bg-white dark:bg-slate-800 rounded-lg border border-gray-200 dark:border-slate-700 p-4"><div class="flex justify-between items-start mb-3"><h3 class="font-semibold text-gray-900 dark:text-gray-100">{{holding.fundName}}</h3><span [class]="holding.gainLossPercentage >= 0 ? 'text-green-500' : 'text-red-500'" class="text-sm font-medium">{{holding.gainLossPercentage >= 0 ? '+' : ''}}{{holding.gainLossPercentage | number:'1.2-2'}}%</span></div>...; implement pagination: <div class="flex justify-between items-center mt-4"><button (click)="previousPage()" [disabled]="currentPage() === 1" class="px-4 py-2 bg-gray-200 dark:bg-slate-700 text-gray-700 dark:text-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-300 dark:hover:bg-slate-600 transition-colors">Previous</button><span class="text-sm text-gray-600 dark:text-gray-400">Page {{currentPage()}} of {{totalPages()}}</span><button (click)="nextPage()" [disabled]="currentPage() === totalPages()" class="px-4 py-2 bg-gray-200 dark:bg-slate-700 text-gray-700 dark:text-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-300 dark:hover:bg-slate-600 transition-colors">Next</button></div>`.

Implement timid validation with Reactive Forms — Create features/onboarding/components/risk-questionnaire/risk-questionnaire.component.ts with multi-step form: currentStep = signal(0), demographicsForm = this.fb.group({ age: [null, [Validators.required, Validators.min(18)]], incomeRange: ['', Validators.required], dependents: [0, [Validators.required, Validators.min(0)]] }), similar for financials/behavioral/goals/preferences forms; implement helper shouldShowError(control: AbstractControl): boolean { return !!(control.invalid && control.touched); } for timid validation; template inputs: <div class="mb-6"><label for="age" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Age *</label><input id="age" type="number" formControlName="age" (blur)="demographicsForm.get('age')!.markAsTouched()" class="w-full px-4 py-2.5 border rounded-lg bg-white dark:bg-slate-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors" [class.border-gray-300]="!shouldShowError(demographicsForm.get('age')!)" [class.dark:border-slate-600]="!shouldShowError(demographicsForm.get('age')!)" [class.border-red-500]="shouldShowError(demographicsForm.get('age')!)">@if (shouldShowError(demographicsForm.get('age')!)) { <p class="mt-1 text-sm text-red-500 dark:text-red-400">@if (demographicsForm.get('age')!.errors?.['required']) { Age is required } @if (demographicsForm.get('age')!.errors?.['min']) { Age must be at least 18 } </p> }</div>; step navigation with validation: nextStep() { this.getCurrentForm().markAllAsTouched(); if (this.getCurrentForm().valid) this.currentStep.update(s => s + 1); }.

Build manual selection with weight validator and full string classes — Create features/portfolio-analysis/components/manual-selection/manual-selection.component.ts with selectionsFormArray = this.fb.array<FormGroup>([]), custom validator totalWeightValidator(): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const arr = control as FormArray; const total = arr.controls.reduce((sum, ctrl) => sum + (ctrl.get('weightPct')?.value || 0), 0); return total === 100 ? null : { totalWeight: { actual: total, required: 100 } }; }; } applied to FormArray, totalWeight = computed(() => this.selectionsValue().reduce((sum, s) => sum + (s.weightPct || 0), 0)) where selectionsValue = toSignal(this.selectionsFormArray.valueChanges.pipe(startWith([])), { initialValue: [] }), fund search with debounce: fundQuery = signal(''), fundSuggestions = signal<FundPickerItemResponse[]>([]), searchFunds = debounceTime(300), switchMap(q => this.api.searchFunds(q)), template displaying selections with footer: <div class="mt-4 flex justify-between items-center px-6 py-4 bg-gray-50 dark:bg-slate-800 border-t border-gray-200 dark:border-slate-700 rounded-b-lg"><span class="text-sm font-semibold text-gray-700 dark:text-gray-300">Total Weight:</span><div class="flex items-center gap-3"><span [class]="totalWeight() === 100 ? 'text-green-500' : 'text-red-500'" class="text-xl font-bold">{{totalWeight()}}%</span><span [class]="totalWeight() === 100 ? 'text-green-500' : 'text-red-500'" class="text-xs">{{totalWeight() === 100 ? '✓ Valid' : '✗ Must equal 100%'}}</span></div></div><button (click)="submitSelection()" [disabled]="selectionsFormArray.invalid || totalWeight() !== 100" class="w-full mt-6 px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-700 active:bg-blue-800 transition-colors">Analyze Portfolio</button>.

Complete API integration with interceptors and polling — Create core/services/api.service.ts with all endpoints: login(req: LoginRequest): Observable<AuthResponse> { return this.http.post<AuthResponse>('${this.baseUrl}/api/v1/auth/login', req); }, submitRiskProfile(req: RiskProfileRequest): Observable<RiskProfileResponse>, uploadPortfolio(file: File): Observable<UploadResponse> { const formData = new FormData(); formData.append('file', file); return this.http.post<UploadResponse>('${this.baseUrl}/api/onboarding/uploads', formData); }, getUploadStatus(uploadId: string): Observable<UploadResponse>, getDashboard(): Observable<DashboardResponse>, searchFunds(query: string, limit = 20): Observable<FundPickerItemResponse[]>, submitManualSelection(req: ManualSelectionRequest): Observable<ManualSelectionResponse>; implement core/interceptors/auth.interceptor.ts: intercept(req: HttpRequest<any>, next: HttpHandler) { const token = localStorage.getItem('access_token'); if (token && !req.url.includes('/auth/')) { req = req.clone({ setHeaders: { Authorization: 'Bearer ${token}' } }); } return next.handle(req); }, core/interceptors/loading.interceptor.ts, core/interceptors/error.interceptor.ts handling 401 redirects and toast messages; create upload polling utility in features/onboarding/components/file-upload/file-upload.component.ts: uploadStatus = signal<UploadResponse | null>(null), startPolling(uploadId: string) { this.pollingSubscription = interval(2000).pipe(switchMap(() => this.api.getUploadStatus(uploadId)), takeWhile(res => res.status === 'parsing' || res.status === 'enriching', true)).subscribe({ next: res => { this.uploadStatus.set(res); if (res.status === 'completed') { this.dashboardState.refresh(); this.toastState.addToast({ severity: 'success', message: 'Portfolio uploaded successfully!' }); } else if (res.status === 'failed') { this.toastState.addToast({ severity: 'error', message: res.errorMessage || 'Upload failed' }); } }, error: err => this.toastState.addToast({ severity: 'error', message: 'Failed to check upload status' }) }); }, ngOnDestroy() { this.pollingSubscription?.unsubscribe(); }.

Implementation Complete
Project Structure:

src/app/
├── core/
│   ├── guards/auth.guard.ts
│   ├── interceptors/{auth,loading,error}.interceptor.ts
│   ├── models/{auth,dashboard,risk,manual}.interface.ts
│   ├── services/api.service.ts
│   └── state/{auth,theme,loading,toast,dashboard}.state.ts
├── features/
│   ├── auth/login.component.ts
│   ├── dashboard/{dashboard,holdings-table,portfolio-summary}.component.ts
│   ├── onboarding/{risk-questionnaire,file-upload,results-dashboard}.component.ts
│   └── portfolio-analysis/{manual-selection,health-report}.component.ts
├── shared/
│   ├── components/{wealth-cone-chart,sector-chart,theme-toggle,loading-overlay,toast}.component.ts
│   └── utils/{chart-registry,chart-theme-config,validators}.ts
└── app.{config,routes}.ts

User Experience: Timid validation prevents premature error messages while maintaining strong validation

Maintainability: Modular architecture with clear separation of concerns, full TypeScript type safety

Angular CLI: 20.2.2
Node: 22.17.0
Package Manager: npm 11.5.1
OS: win32 x64